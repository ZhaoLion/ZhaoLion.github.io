<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zhaolion&#39;s dropbox</title>
    <link>http://zhaolion.github.io/</link>
    <description>Recent content on zhaolion&#39;s dropbox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 12 Jan 2019 11:43:35 +0800</lastBuildDate>
    
	<atom:link href="http://zhaolion.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>初步了解 golang reflect pkg</title>
      <link>http://zhaolion.github.io/post/golang/package/reflect/</link>
      <pubDate>Sat, 12 Jan 2019 11:43:35 +0800</pubDate>
      
      <guid>http://zhaolion.github.io/post/golang/package/reflect/</guid>
      <description>初步了解 golang reflect pkg [TOC]
阅读这篇文章之前，建议先熟悉官方文档 pkg/reflect
Golang 语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的 reflect 包就是反射相关的，只要包含这个包就可以使用。实际使用中可以先不考虑使用 reflect 对性能的影响，先实现功能，再利用 benchmark test 去优化。
什么时候应该用 reflect
 首先你得确认你会使用 reflect pkg，并且不是乱用 更好的抽象和约束，减少 bug 几率 提升代码的易读性 提高开发效率  1 理解 Type &amp;amp; Kind &amp;amp; Value reflect package 提供了 3 个重要的结构体 Type、Kind 和 Value: - Type: 就是 Go concrete type, 例如 int/string/bool/customStruct &amp;hellip; - Kind: 就是 Go static type(固定的)，例如 Boot/Int/Struct &amp;hellip; - Value: 也就是 Go value, 承载变量 / 常量的值
 type Kind uint Kind 用途: 用于 runtime 和 compiler 为变量分配变量内存布局和函数分配堆栈</description>
    </item>
    
    <item>
      <title>初步了解 golang bufio pkg</title>
      <link>http://zhaolion.github.io/post/golang/package/bufio/</link>
      <pubDate>Sat, 13 Oct 2018 21:54:10 +0800</pubDate>
      
      <guid>http://zhaolion.github.io/post/golang/package/bufio/</guid>
      <description>bufio package in Golang golang 通过 package bufio 来支持 buffered I/O。
熟悉一下: Reader, Writer and Scanner…
bufio.Writer 对 I/O 的频繁操作会极大的影响性能，每次 写 I/O 都是一次 syscall，因此频繁操作会给 CPU 带来极大的负担。对于磁盘来说，批量写操作有着更好的性能。golang 通过 bufio.Writer 来合并写操作，避免频繁的写操作。因此在写密集场景下，应该使用 bufio.Writer，而不是 io.Writer
bufio.Writer 通过将写内容缓存至 buffer，buffer 满了之后，再进行一次写操作，这样极大的优化性能:
producer --&amp;gt; buffer --&amp;gt; io.Writer  举个例子，9 次写操作，buffer 是如何工作的:
producer buffer destination (io.Writer) a -----&amp;gt; a b -----&amp;gt; ab c -----&amp;gt; abc d -----&amp;gt; abcd e -----&amp;gt; e ------&amp;gt; abcd f -----&amp;gt; ef abcd g -----&amp;gt; efg abcd h -----&amp;gt; efgh abcd i -----&amp;gt; i ------&amp;gt; abcdefgh  看份代码来感受一下，如何使用:</description>
    </item>
    
    <item>
      <title>Go Interface 从理解到深入</title>
      <link>http://zhaolion.github.io/post/golang/basic/interface/</link>
      <pubDate>Thu, 13 Sep 2018 18:24:50 +0800</pubDate>
      
      <guid>http://zhaolion.github.io/post/golang/basic/interface/</guid>
      <description>Go Interface 从理解到深入 如果说 goroutine 和 channel 是 Go 并发的两大基石，那么接口是 Go 语言编程中数据类型的关键。在 Go 语言的实际编程中，几乎所有的数据结构都围绕接口展开，接口是 Go 语言中所有数据结构的核心
Go 不是一种典型的 OO 语言，它在语法上不支持类和继承的概念
没有继承是否就无法拥有多态行为了呢？答案是否定的，Go 语言引入了一种新类型—Interface，它在效果上实现了类似于 C++ 的 “多态” 概念，虽然与 C++ 的多态在语法上并非完全对等，但至少在最终实现的效果上，它有多态的影子
虽然 Go 语言没有类的概念，但它支持的数据类型可以定义对应的 method(s)。本质上说，所谓的 method(s) 其实就是函数，只不过与普通函数相比，这类函数是作用在某个数据类型上的，所以在函数签名中，会有个 receiver(接收器) 来表明当前定义的函数会作用在该 receiver 上
Go 语言支持的除 Interface 类型外的任何其它数据类型都可以定义其 method（而并非只有 struct 才支持 method），只不过实际项目中，method(s) 多定义在 struct 上而已。 从这一点来看，我们可以把 Go 中的 struct 看作是不支持继承行为的轻量级的 “类”，这一点比较类似 Abstract Class
从语法上看，Interface 定义了一个或一组 method(s)，这些 method(s) 只有函数签名，没有具体的实现代码（有没有联想起 C++ 中的虚函数？）。若某个数据类型实现了 Interface 中定义的那些被称为 &amp;ldquo;methods&amp;rdquo; 的函数，则称这些数据类型实现（implement）了 interface。这是我们常用的 OO 方式</description>
    </item>
    
    <item>
      <title>如何写好 golang 代码的一些 tips</title>
      <link>http://zhaolion.github.io/post/golang/tips/coding.in.go/</link>
      <pubDate>Mon, 02 Jul 2018 21:12:55 +0800</pubDate>
      
      <guid>http://zhaolion.github.io/post/golang/tips/coding.in.go/</guid>
      <description>如何写好 golang 代码的一些 tips 1. 首先需要知道的概念  不要像其他语言一样写 Go, Go 不是 Java/Python/Ruby/PHP，Go 的程序思维很古典也很超前 保持简洁，避免过度工程化 学会阅读源码 interface 很重要，很多问题都可以用 interface 解决 保持函数精炼，变量名长度合适 (在不丢失意义的情况下，尽量短小) 用更小的单元实现代码功能，然后 ** 组合 ** 慎重使用全局变量 (尤其是跨 package 使用，变量作用域上容易踩坑，可以参考 vs6IeAu5U5n)  2. 函数声明的 tips  函数声明首先是函数名字要具有自解释性，需要能够解释清楚大致提供的功能，而不是模糊的 common/util。 其次具体的功能解释，这个要说到代码注释了，这里就不赘述了。 除了函数声明外，还有函数的形参定义。这里以一个例子来说一下扩展性好的函数的参数应该如何定义 (见 2.1)。  2.1 普通函数 假设我们需要一个简单的 server，我们可以像下面这样定义，addr 表示 server 启动在哪个端口上。
func NewServer(addr string)  第一期的需求很简单，就上面这些足够满足了。项目上线跑了一段时间发现，由于连接没有设置超时，很多连接一直得不到释放（异常情况），严重影响服务器性能。
好，那第二期我们加个 timeout。
func NewServer(addr string, timeout time.Duration)  这个时候尴尬的情况出现了，调用你代码的所有人都需要改动代码。而且这只是一个改动，之后如果要支持 tls，那么又得改动一次。
2.2 不定参数 解决上面的窘境的一种方法是使用不定参数。
比如我要实现一个整数加法。
func Add(list .</description>
    </item>
    
    <item>
      <title>正则表达式基本使用介绍</title>
      <link>http://zhaolion.github.io/post/regexp/basic/</link>
      <pubDate>Fri, 13 Jan 2017 18:48:34 +0800</pubDate>
      
      <guid>http://zhaolion.github.io/post/regexp/basic/</guid>
      <description>正则表达式有两种风格：posix和perl风格，最常用是posix风格的。下面记录的均是posix风格
字符集和类  通配符，可以匹配除换行符（\\n）之外的任意一个字符 &amp;gt;.at，可以匹配&amp;rdquo;cat&amp;rdquo;,&amp;ldquo;sat&amp;rdquo;,&amp;ldquo;mat&amp;rdquo;等，一般这种通配符用于匹配操作系统中的文件名
 限定范围 &amp;gt; 1. 如果要限定匹配的范围，可以使用[a-z]at形式，任何包括在方括号中的内容都是一个字符类－匹配字符所属的字符集合 &amp;gt;2. 可以列出一个集合，[aeiou]，来匹配所有元音字母 &amp;gt;3. 也可以描述一个范围，正如前面的连字符，也是一个范围集:[a-zA-Z]，这个集合代表任何的大小字母 &amp;gt;4. 也可以指明不属于某个集合，[^a-z]，用来匹配不在小写字母中的字符
  重复 如果希望某个字符串或者字符类不止一次出现，可以使用2个特殊字符代替:*和+，这两个符号放在表示式后面 - *表示这个模式可以重复0次或多次 - +表示这个模式可以重复1次或更多次
 c+at，表示可以匹配&amp;rdquo;cat&amp;rdquo;,&amp;ldquo;ccat&amp;rdquo;,&amp;ldquo;cccat&amp;rdquo;，但是无法匹配&amp;rdquo;at&amp;rdquo; c*at，表示可以匹配&amp;rdquo;cat&amp;rdquo;,&amp;ldquo;ccat&amp;rdquo;,&amp;ldquo;cccat&amp;rdquo;，也可以匹配&amp;rdquo;at&amp;rdquo;
 子表达式 通常，将一个表达式分为几个子表达式非常有用，使用圆括号来实现。
 (very )*large，可以匹配：&amp;rdquo;large&amp;rdquo;,&amp;ldquo;very large&amp;rdquo;,&amp;ldquo;very very large&amp;rdquo;
 子表达式计数 可以在花括号{}中的数字表达式来指定内容允许重复出现的次数。可以指定一个确切的数字，也可以是一个重复次数范围，或是一个开区间的重复范围
 (very){1, 2}，可以匹配&amp;rdquo;very&amp;rdquo;,&amp;ldquo;veryvery&amp;rdquo; (very){3}，可以匹配&amp;rdquo;veryveryvery&amp;rdquo; (very)(1,)，可以匹配&amp;rdquo;very&amp;rdquo;,&amp;ldquo;veryvery&amp;rdquo;,&amp;ldquo;veryveryvery&amp;rdquo;&amp;hellip;
 定位到字符串的开始或末尾 脱字符号^用于正则表达式的开始，表示子字符串必须出现被搜索字符串的开始处 字符$，用于正则表达式的末尾，表示子字符串必须出现在字符串的末尾
 ^bob，用于在字符串开始处匹配bob com$,用于在字符串末尾处匹配com ^[a-z]$，这个将只能匹配a-z之间的字符组成的字符串
 分支 可以使用正则表达式中一条竖线，来表示一个选择 com|edu|net，来匹配&amp;rdquo;com&amp;rdquo;,&amp;ldquo;net&amp;rdquo;,&amp;ldquo;edu&amp;rdquo;中任意一个
匹配特殊字符 如果要匹配那些特殊字符，需要使用转义形式，在要匹配的字符前面加一个反斜杠\\
特殊字符主要有： - \: 转义字符 - ^: 在字符串开始匹配 - $: 在字符串末尾匹配 - .</description>
    </item>
    
    <item>
      <title>MySQL的基础使用相关知识</title>
      <link>http://zhaolion.github.io/post/mysql/basic/</link>
      <pubDate>Fri, 13 Jan 2017 18:45:26 +0800</pubDate>
      
      <guid>http://zhaolion.github.io/post/mysql/basic/</guid>
      <description>登录到MySQL mysql -h hostname -P hostport -u username -p
 -h 指定希望连接的主机，可以用来连接远程主机上的MySQL，如果忽略默认登录本机数据库 -P 指定所连接主机开放的MySQL端口，如果忽略此项默认使用3306端口登录 -u 指定连接数据库时使用的用户名称，如果忽略此项默认使用你的本机用户名 -p 告诉服务器会使用密码来连接数据库，如果忽略此项使用无密码登录  使用密码登入时，会出现以下响应
Enter password:  输入密码后成功登录会得到以下响应
Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 4 Server version: 5.7.12 MySQL Community Server (GPL) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates.</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>http://zhaolion.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zhaolion.github.io/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>